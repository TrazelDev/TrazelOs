#pragma once
#include "utility/utility.h"

// links used to create this file:
// https://wiki.osdev.org/ATA_PIO_Mode
// https://wiki.osdev.org/PCI_IDE_Controller

#define IS_IO_REGISTER(reg)           (reg <= DEVICE_REGISTERS_OFFSETS::command_register)
#define IS_CONTROL_BASE_REGISTER(reg) (DEVICE_REGISTERS_OFFSETS::device_control_register <= reg && reg <= DEVICE_REGISTERS_OFFSETS::drive_address_register)
#define IS_DMA_REGISTER(reg)          (reg >= DEVICE_REGISTERS_OFFSETS::seccount1_register)

// this are the ide ports:
#define MASTER_IDE_IO_PORT      0x1F0
#define MASTER_IDE_CONTROL_PORT 0x3F6

// this are the drives:
#define MASER_DRIVE 0xA0
#define SLAVE_DRIVE 0xB0

#define ADJUST_DEVICE_OFFSET_TO_CORRECT_OFFSET(deviceRegister) (deviceRegister < DEVICE_REGISTERS_OFFSETS::device_control_register ? deviceRegister : deviceRegister - DEVICE_REGISTERS_OFFSETS::device_control_register)
enum DEVICE_REGISTERS_OFFSETS
{
   // Registers that correspond to the io base port:
   data_register             = 0,   // Direction: ( R/W ), Read/Write PIO data bytes
   error_register            = 1,   // Direction: ( R	  ), Used to retrieve any error generated by the last ATA command executed.
   features_register         = 1,   // Direction: (   W ), Used to control command specific interface features.
   sector_count_register     = 2,   // Direction: ( R/W ), Number of sectors to read/write (0 is a special value).
   sector_number_register    = 3,   // Direction: ( R/W ), This is CHS / LBA28 / LBA48 specific.
   cylinder_low_register     = 4,   // Direction: ( R/W ), Partial Disk Sector address.
   cylinder_high_register    = 5,   // Direction: ( R/W ), Partial Disk Sector address.
   drive_register            = 6,   // Direction: ( R/W ), Used to select a drive and/or head. Supports extra address/flag bits.	
   status_register           = 7,   // Direction: ( R	  ), Used to read the current status.
   command_register          = 7,   // Direction: (   W ), Used to send ATA commands to the device.


   // Registers that correspond to the control base port: 
   device_control_register   = 8,   // Direction: (   W ), This register is used to control various aspects of the ATA device, such as device reset and interrupt enable/disable.
   alternate_status_register = 8,   // Direction: ( R	  ), This register serves as an alternative status register, 
   drive_address_register    = 9,   // Direction: (   W ), This register is used to set the device address for devices on a bus, enabling communication with specific ATA devices in a multi-drive configuration.


   // Registers for optimizations DMA (Direct Memory Access):
   seccount1_register        = 8,   // Direction: ( R/W ), This register holds the high bits of the sector count for LBA48 addressing mode.
   lba3_register             = 9,   // Direction: ( R/W ), This register holds the high bits of the LBA address for LBA48 addressing mode.
   lba4_register             = 10,  // Direction: ( R/W ), This register holds the highest bits of the LBA address for LBA48 addressing mode.
   lba5_register             = 11,  // Direction: ( R/W ), This register holds additional bits of the LBA address for LBA48 addressing mode.
};

// Registers bit masks:
// Status register bit masks:
#define ATA_SR_BSY          0x80    // Busy
#define ATA_SR_DRDY         0x40    // Drive ready
#define ATA_driveIndexSR_DF 0x20    // Drive write fault
#define ATA_SR_DSC          0x10    // Drive seek complete
#define ATA_SR_DRQ          0x08    // Data request ready
#define ATA_SR_CORR         0x04    // Corrected data
#define ATA_SR_IDX          0x02    // Index
#define ATA_SR_ERR          0x01    // Error
// Error register bit masks:
#define ATA_ER_BBK          0x80    // Bad block
#define ATA_ER_UNC          0x40    // Uncorrectable data
#define ATA_ER_MC           0x20    // Media changed
#define ATA_ER_IDNF         0x10    // ID mark not found
#define ATA_ER_MCR          0x08    // Media change request
#define ATA_ER_ABRT         0x04    // Command aborted
#define ATA_ER_TK0NF        0x02    // Track 0 not found
#define ATA_ER_AMNF         0x01    // No address mark


// Command register supported commands:
#define ATA_CMD_READ_PIO          0x20
#define ATA_CMD_READ_PIO_EXT      0x24
#define ATA_CMD_READ_DMA          0xC8
#define ATA_CMD_READ_DMA_EXT      0x25
#define ATA_CMD_WRITE_PIO         0x30
#define ATA_CMD_WRITE_PIO_EXT     0x34
#define ATA_CMD_WRITE_DMA         0xCA
#define ATA_CMD_WRITE_DMA_EXT     0x35
#define ATA_CMD_CACHE_FLUSH       0xE7
#define ATA_CMD_CACHE_FLUSH_EXT   0xEA
#define ATA_CMD_PACKET            0xA0
#define ATA_CMD_IDENTIFY_PACKET   0xA1
#define ATA_CMD_IDENTIFY          0xEC


// control register values:
#define ATA_REG_CONTROL_IRQ_ENABLE_MASK 0x80


// ATA_CMD_IDENTIFY_PACKET and ATA_CMD_IDENTIFY return a buffer of 512 bytes called the identification space; the following definitions are used to read information from the identification space:
#define ATA_IDENT_DEVICETYPE   0
#define ATA_IDENT_CYLINDERS    2
#define ATA_IDENT_HEADS        6
#define ATA_IDENT_SECTORS      12
#define ATA_IDENT_SERIAL       20
#define ATA_IDENT_MODEL        54
#define ATA_IDENT_CAPABILITIES 98
#define ATA_IDENT_FIELDVALID   106
#define ATA_IDENT_MAX_LBA      120
#define ATA_IDENT_COMMANDSETS  164
#define ATA_IDENT_MAX_LBA_EXT  200



// specifying the interface of the drive:
#define IDE_ATA        0x00 // For the ATA technology that is used for ATA, PATA and SATA drives
#define IDE_ATAPI      0x01 // For non traditional storage devices like ( CD-ROM drives, DVD drives, and tape drives ) it stands for ( AT Attachment Packet interface)

enum DRIVE_CHANEL_NUMBER
{
   MASTER_CHANEL = 0,
   SLAVE_CHANEL  = 1,

   CHANEL_COUNT        = 2
};

// this struct represents the register that will associated with each IDE
typedef struct
{
   uint16_t basePort;
   uint16_t controlPort;
   uint16_t busMasterInterfacePort; 
   bool     noInterrupt;
} __attribute__((packed)) IDEChannelRegisters;



#define MODEL_LENGTH 40
typedef struct
{
   uint8_t  Reserved;                // 0 (Empty) or 1 (This Drive really exists).
   uint8_t  Channel;                 // 0 (Primary Channel) or 1 (Secondary Channel).
   uint8_t  Drive;                   // 0 (Master Drive) or 1 (Slave Drive).
   uint16_t Type;                    // 0: ATA, 1:ATAPI.
   uint16_t Signature;               // Drive Signature
   uint16_t Capabilities;            // Features.
   uint32_t CommandSets;             // Command Sets Supported.
   uint32_t Size;                    // Size in Sectors.
   uint8_t  Model[MODEL_LENGTH + 1]; // Model in string.
} __attribute__((packed)) IDEDevice;

#define DRIVES_SUPPORTED 2
#define IDE_BUFFER_SIZE 2048

// ATAPI commands:
#define ATAPI_COMMAND_BUFFER_SIZE 12
#define IDENTIFY_PACKED_DEVICE    0xA8